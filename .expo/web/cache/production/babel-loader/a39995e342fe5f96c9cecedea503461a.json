{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";function _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}import Platform from\"react-native-web/dist/exports/Platform\";import findNodeHandleRN from\"react-native-web/dist/exports/findNodeHandle\";import{handlerIDToTag}from\"./handlersRegistry\";import{toArray}from\"../utils\";var commonProps=['id','enabled','shouldCancelWhenOutside','hitSlop'];var componentInteractionProps=['waitFor','simultaneousHandlers'];export var baseGestureHandlerProps=[].concat(commonProps,componentInteractionProps,['onBegan','onFailed','onCancelled','onActivated','onEnded','onGestureEvent','onHandlerStateChange']);export var baseGestureHandlerWithMonitorProps=[].concat(commonProps,['needsPointerData','manualActivation']);function isConfigParam(param,name){return param!==undefined&&(param!==Object(param)||!('__isNative'in param))&&name!=='onHandlerStateChange'&&name!=='onGestureEvent';}export function filterConfig(props,validProps){var defaults=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var filteredConfig=_objectSpread({},defaults);for(var _iterator=_createForOfIteratorHelperLoose(validProps),_step;!(_step=_iterator()).done;){var key=_step.value;var value=props[key];if(isConfigParam(value,key)){if(key==='simultaneousHandlers'||key==='waitFor'){value=transformIntoHandlerTags(props[key]);}else if(key==='hitSlop'&&typeof value!=='object'){value={top:value,left:value,bottom:value,right:value};}filteredConfig[key]=value;}}return filteredConfig;}function transformIntoHandlerTags(handlerIDs){handlerIDs=toArray(handlerIDs);if(Platform.OS==='web'){return handlerIDs.map(function(_ref){var current=_ref.current;return current;}).filter(function(handle){return handle;});}return handlerIDs.map(function(handlerID){var _handlerID$current;return handlerIDToTag[handlerID]||((_handlerID$current=handlerID.current)===null||_handlerID$current===void 0?void 0:_handlerID$current.handlerTag)||-1;}).filter(function(handlerTag){return handlerTag>0;});}export function findNodeHandle(node){if(Platform.OS==='web')return node;return findNodeHandleRN(node);}","map":{"version":3,"sources":["gestureHandlerCommon.ts"],"names":["commonProps","componentInteractionProps","baseGestureHandlerProps","baseGestureHandlerWithMonitorProps","param","Object","name","defaults","filteredConfig","value","props","isConfigParam","key","transformIntoHandlerTags","top","left","bottom","right","handlerIDs","toArray","Platform","current","handle","handlerID","handlerIDToTag","handlerTag","findNodeHandleRN"],"mappings":"2/DAUA,OAAA,cAAA,0BACA,OAAA,OAAA,gBAEA,GAAMA,YAAW,CAAG,CAAA,IAAA,CAAA,SAAA,CAAA,yBAAA,CAApB,SAAoB,CAApB,CAOA,GAAMC,0BAAyB,CAAG,CAAA,SAAA,CAAlC,sBAAkC,CAAlC,CAEA,MAAO,IAAMC,wBAAuB,WAAG,WAAH,CAAG,yBAAH,EAAG,SAAH,CAAG,UAAH,CAAG,aAAH,CAAG,aAAH,CAAG,SAAH,CAAG,gBAAH,CAA7B,sBAA6B,EAA7B,CAYP,MAAO,IAAMC,mCAAkC,WAAG,WAAH,EAAG,kBAAH,CAAxC,kBAAwC,EAAxC,CAgGP,QAAA,cAAA,CAAA,KAAA,CAAA,IAAA,CAAqD,CAGnD,MACEC,MAAK,GAALA,SAAAA,GACCA,KAAK,GAAKC,MAAM,CAAhBD,KAAgB,CAAhBA,EACC,EAAE,cAFJA,MAEE,CAFFA,GAGAE,IAAI,GAHJF,sBAAAA,EAIAE,IAAI,GALN,gBAAA,CAOD,CAED,MAAO,SAAA,aAAA,CAAA,KAAA,CAAA,UAAA,CAIL,IADAC,SACA,2DAJK,EAIL,CACA,GAAMC,eAAc,kBAAQD,QAAR,CAApB,CACA,kDAAA,UAAA,mCAA8B,IAA9B,IAA8B,aAC5B,GAAIE,MAAK,CAAGC,KAAK,CAAjB,GAAiB,CAAjB,CACA,GAAIC,aAAa,CAAA,KAAA,CAAjB,GAAiB,CAAjB,CAA+B,CAC7B,GAAIC,GAAG,GAAHA,sBAAAA,EAAkCA,GAAG,GAAzC,SAAA,CAAyD,CACvDH,KAAK,CAAGI,wBAAwB,CAACH,KAAK,CAAtCD,GAAsC,CAAN,CAAhCA,CADF,CAAA,IAEO,IAAIG,GAAG,GAAHA,SAAAA,EAAqB,MAAA,MAAA,GAAzB,QAAA,CAAoD,CACzDH,KAAK,CAAG,CAAEK,GAAG,CAAL,KAAA,CAAcC,IAAI,CAAlB,KAAA,CAA2BC,MAAM,CAAjC,KAAA,CAA0CC,KAAK,CAAER,KAAjD,CAARA,CACD,CACDD,cAAc,CAAdA,GAAc,CAAdA,CAAAA,KAAAA,CACD,CACF,CACD,MAAA,eAAA,CACD,CAED,QAAA,yBAAA,CAAA,UAAA,CAAmD,CACjDU,UAAU,CAAGC,OAAO,CAApBD,UAAoB,CAApBA,CAEA,GAAIE,QAAQ,CAARA,EAAAA,GAAJ,KAAA,CAA2B,CACzB,MAAOF,WAAU,CAAVA,GAAAA,CACA,kBAAGG,QAAH,MAAGA,OAAH,OADAH,QACA,EADAA,EAAAA,MAAAA,CAEII,SAAAA,MAAD,QAFV,OAEU,EAFHJ,CAAP,CAJ+C,CASjD,MAAO,WAAU,CAAV,GAAA,CAEFK,SAAAA,SAAD,CAAA,CAAA,GAAA,mBAAA,CAAA,MACEC,eAAc,CAAdA,SAAc,CAAdA,GAAAA,CAAAA,kBAAAA,CAA6BD,SAAS,CAAtCC,OAAAA,IAAAA,IAAAA,EAAAA,kBAAAA,GAAAA,IAAAA,EAAAA,CAAAA,IAAAA,EAAAA,CAA6BD,kBAAAA,CAA7BC,UAAAA,GAA8D,CADhE,CAAA,CAFG,CAAA,EAAA,MAAA,CAKIC,SAAAA,UAAD,QAAwBA,WAAU,CAL5C,CAKU,EALH,CAAP,CAMD,CAED,MAAO,SAAA,eAAA,CAAA,IAAA,CAEkE,CACvE,GAAIL,QAAQ,CAARA,EAAAA,GAAJ,KAAA,CAA2B,MAAA,KAAA,CAC3B,MAAOM,iBAAgB,CAAvB,IAAuB,CAAvB,CACD","sourcesContent":["// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\nimport * as React from 'react';\nimport { Platform, findNodeHandle as findNodeHandleRN } from 'react-native';\n\nimport { State } from '../State';\nimport { EventType } from '../EventType';\nimport { ValueOf } from '../typeUtils';\nimport { handlerIDToTag } from './handlersRegistry';\nimport { toArray } from '../utils';\n\nconst commonProps = [\n  'id',\n  'enabled',\n  'shouldCancelWhenOutside',\n  'hitSlop',\n] as const;\n\nconst componentInteractionProps = ['waitFor', 'simultaneousHandlers'] as const;\n\nexport const baseGestureHandlerProps = [\n  ...commonProps,\n  ...componentInteractionProps,\n  'onBegan',\n  'onFailed',\n  'onCancelled',\n  'onActivated',\n  'onEnded',\n  'onGestureEvent',\n  'onHandlerStateChange',\n] as const;\n\nexport const baseGestureHandlerWithMonitorProps = [\n  ...commonProps,\n  'needsPointerData',\n  'manualActivation',\n];\n\nexport interface GestureEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n}\n\nexport interface HandlerStateChangeEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n  oldState: ValueOf<typeof State>;\n}\n\nexport type HitSlop =\n  | number\n  | Partial<\n      Record<\n        'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\n        number\n      >\n    >\n  | Record<'width' | 'left', number>\n  | Record<'width' | 'right', number>\n  | Record<'height' | 'top', number>\n  | Record<'height' | 'bottom', number>;\n\n//TODO(TS) events in handlers\n\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\n}\nexport interface HandlerStateChangeEvent<\n  ExtraEventPayloadT = Record<string, unknown>\n> {\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\n}\n\nexport type TouchData = {\n  id: number;\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport type GestureTouchEvent = {\n  handlerTag: number;\n  numberOfTouches: number;\n  state: ValueOf<typeof State>;\n  eventType: EventType;\n  allTouches: TouchData[];\n  changedTouches: TouchData[];\n};\n\nexport type GestureUpdateEvent<\n  GestureEventPayloadT = Record<string, unknown>\n> = GestureEventPayload & GestureEventPayloadT;\n\nexport type GestureStateChangeEvent<\n  GestureStateChangeEventPayloadT = Record<string, unknown>\n> = HandlerStateChangeEventPayload & GestureStateChangeEventPayloadT;\n\nexport type CommonGestureConfig = {\n  enabled?: boolean;\n  shouldCancelWhenOutside?: boolean;\n  hitSlop?: HitSlop;\n};\n\n// Events payloads are types instead of interfaces due to TS limitation.\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\nexport type BaseGestureHandlerProps<\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\n> = CommonGestureConfig & {\n  id?: string;\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\n  // TODO(TS) - fix event types\n  onBegan?: (event: HandlerStateChangeEvent) => void;\n  onFailed?: (event: HandlerStateChangeEvent) => void;\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\n  onActivated?: (event: HandlerStateChangeEvent) => void;\n  onEnded?: (event: HandlerStateChangeEvent) => void;\n\n  //TODO(TS) consider using NativeSyntheticEvent\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\n  onHandlerStateChange?: (\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\n  ) => void;\n};\n\nfunction isConfigParam(param: unknown, name: string) {\n  // param !== Object(param) returns false if `param` is a function\n  // or an object and returns true if `param` is null\n  return (\n    param !== undefined &&\n    (param !== Object(param) ||\n      !('__isNative' in (param as Record<string, unknown>))) &&\n    name !== 'onHandlerStateChange' &&\n    name !== 'onGestureEvent'\n  );\n}\n\nexport function filterConfig(\n  props: Record<string, unknown>,\n  validProps: string[],\n  defaults: Record<string, unknown> = {}\n) {\n  const filteredConfig = { ...defaults };\n  for (const key of validProps) {\n    let value = props[key];\n    if (isConfigParam(value, key)) {\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\n        value = transformIntoHandlerTags(props[key]);\n      } else if (key === 'hitSlop' && typeof value !== 'object') {\n        value = { top: value, left: value, bottom: value, right: value };\n      }\n      filteredConfig[key] = value;\n    }\n  }\n  return filteredConfig;\n}\n\nfunction transformIntoHandlerTags(handlerIDs: any) {\n  handlerIDs = toArray(handlerIDs);\n\n  if (Platform.OS === 'web') {\n    return handlerIDs\n      .map(({ current }: { current: any }) => current)\n      .filter((handle: any) => handle);\n  }\n  // converts handler string IDs into their numeric tags\n  return handlerIDs\n    .map(\n      (handlerID: any) =>\n        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1\n    )\n    .filter((handlerTag: number) => handlerTag > 0);\n}\n\nexport function findNodeHandle(\n  node: null | number | React.Component<any, any> | React.ComponentClass<any>\n): null | number | React.Component<any, any> | React.ComponentClass<any> {\n  if (Platform.OS === 'web') return node;\n  return findNodeHandleRN(node);\n}\n"]},"metadata":{},"sourceType":"module"}